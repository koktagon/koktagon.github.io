/*

    EPAPI5 Compatibility Layer

    Copyright 2018 EndPwn Project
    
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    DO NOT EDIT THIS FILE! Your bootstrap may overwrite changes to it, and you will lose your work!
    EndPwn3 users: You can prevent this by creating a file in the same directory named DONTUPDATE
    
    https://github.com/endpwn/

*/

// HACK: this entire file

// old "sandbox" function from EPAPI5
function evaluate(code, include = {}) {
    var prefix = Object.keys(include).map(x => `var ${x}=include.${x}`).join(';') + ';var exports={};';
    var suffix = ';exports';
    return eval(prefix + code + suffix);
}

(() => {

    const fs = require('fs');
    const vm = require('vm');
    const electron = require('electron');
    const data = endpwn.data;

    function debug(str) {
        console.debug(`%c[Compatibility]%c ` + str, 'font-weight:bold;color:#0cc', '');
    }
    function print(str) {
        console.log(`%c[Compatibility]%c ` + str, 'font-weight:bold;color:#0cc', '');
    }
    function warn(str) {
        console.warn(`%c[Compatibility]%c ` + str, 'font-weight:bold;color:#0cc', '');
    }
    function error(e, t) {
        if (t === undefined) t = 'uncaught exception';
        console.error(`%c[Compatibility]%c ${t}:\n\n`, 'font-weight:bold;color:#0cc', '', e);
    }

    // prevent init from trying to resolve things we've already handled
    function addResolution(key, id) {
        if (endpwn.loader.resolved[key])
            endpwn.loader.resolved[key].push(id)
        else
            endpwn.loader.resolved[key] = [id];
    }

    // $api constructor
    function epapi5() {

        var $api = {

            notice: 'This is the EPAPI5 compatibility layer object. You SHOULD NOT use it in EPAPI6 plugins.',

            version: {

                major: 5,
                minor: 7,
                revision: 48,

                toString: function () {
                    return `v${this.major}.${this.minor}.${this.revision}`;
                }

            },

            xyzzy: 'Nothing happened.',

            bootstrap: endpwn.bootstrap,
            data: endpwn.data,

            get lite() { return false; },

            get settings() { return DiscordNative.globals.appSettings },

            // shim because i cant be fucked to figure out why ObjectStorage is giving me grief
            localStorage: {

                set: (k, v) => {
                    try {
                        localStorage[k] = JSON.stringify(v);
                    }
                    catch (_) { }
                },

                get: k => {
                    try {
                        return JSON.parse(localStorage[k]);
                    }
                    catch (_) { }
                },

                remove: k => {
                    try {
                        return delete localStorage[k];
                    }
                    catch (_) { }
                }

                // not reimplementing clear because no plugin should reasonably use it 

            },

            get util() {

                var util = mrequire('xyz.dr1ft.epapi.core');

                // shims for util not being able to see $api
                util.wrap = function (target1, callback) {

                    // for security; we're evaluating an untrusted expression in the local scope here
                    //var internal = {};

                    // get the original function
                    var orig = eval(target1);

                    // the stub we will overwrite the function with
                    function stub() {

                        // what we will pass to the original function
                        var args;

                        try {
                            // call the wrapper and get our args
                            args = callback.apply(null, arguments);
                        }
                        catch (e) {
                            error(e, 'A function wrapper threw an exception');

                            // dont completely break the function if there's a flaw in the wrapper
                            args = arguments;
                        }

                        // returning undefined results in the function call being suppressed
                        if (typeof (args) != 'undefined') {
                            // call the original function
                            return orig.apply(null, args)
                        }

                    }

                    stub.original = orig;
                    stub.callback = callback;
                    callback = callback.bind(stub);

                    // do the overwriting thing
                    eval(`${target1}=stub`);

                }

                util.wrapAfter = function (target1, callback) {

                    //var internal = {};

                    // get the original function
                    var orig = eval(target1);

                    // the stub we will overwrite the function with
                    function stub() {

                        // call the original argument
                        var r = orig.apply(null, arguments);

                        try {
                            // call the wrapper and return its return value
                            return callback(r);
                        }
                        catch (e) {
                            error(e, 'A function wrapper threw an exception');

                            // again, dont fuck stuff up if there's a flaw in the wrapper
                            return r;
                        }

                    }

                    stub.original = orig;
                    stub.callback = callback;
                    callback = callback.bind(stub);

                    // overwrite that shit
                    eval(`${target1}=stub`);

                }

                return util;
            },
            get internal() { return mrequire('xyz.dr1ft.epapi.internal') },
            get events() {
                var events = {};
                Object.assign(events, mrequire('xyz.dr1ft.epapi.events'));
                events.listen = events.hook; // shim for listen not being in EPAPI6
                return events;
            },
            get ui() { return mrequire('xyz.dr1ft.epapi.ui') },

            // old rest-based interface
            discord: {

                // take a wild guess
                rest: async function (method, endpoint, body, c) {

                    // the url we will be making our request to
                    var url = "https://discordapp.com/api/v6" + endpoint;

                    // fetch() options
                    var options = {
                        headers: {
                            // get the token from localStorage as our auth header
                            'Authorization': exports.internal.objectStorage.impl.get('token'),
                            'Content-type': 'application/json'
                        },
                        method: method
                    };

                    // if the body isnt already a string go ahead and stringify it
                    if (typeof (body) !== 'string') body = JSON.stringify(body);

                    // probably not the best way to handle this
                    if (method !== 'GET') options.body = body;

                    // fetch
                    var r = await fetch(url, options);
                    if (!r.ok)
                        throw Error(await r.text());

                    // urgh, theyre using callbacks
                    if (c !== undefined) {

                        // warn the dev
                        internal.warn("Using callbacks in REST calls is deprecated and may be removed in a future release.");

                        // operate like EPAPI =<5.0
                        c(await r.text());
                    }
                    else {
                        return await r.json();
                    }

                },

                // mark a message read
                ack: function (channel, id) {
                    return this.rest('POST', `/channels/${channel}/messages/${id}/ack`);
                },

                sendMessage: function (channel, text) {
                    return this.rest('POST', `/channels/${channel}/messages`, { content: text });
                },

                sendEmbed: function (channel, ebd) {
                    return this.rest('POST', `/channels/${channel}/messages`, { embed: ebd }
                    );
                },

                getGuild: function (id, c) {
                    return this.rest('GET', `/guilds/${id}`, '', c ? e => c(JSON.parse(e)) : undefined);
                },

                getChannel: function (id, c) {
                    return this.rest('GET', '/channels/' + id, '', c ? e => c(JSON.parse(e)) : undefined);
                },

                getUser: function (id) {
                    return exports.internal.user.getUser(id);
                },

                getCurrentUser: function () {
                    return exports.internal.user.getCurrentUser();
                },

                getGuildRoles: function (id, c) {
                    return this.rest('GET', `/guilds/${id}/roles`, '', c ? e => c(JSON.parse(e)) : undefined);
                },

                getGuildChannels: function (id, c) {
                    return this.rest('GET', `/guilds/${id}/channels`, '', c ? e => c(JSON.parse(e)) : undefined);
                },

                getGuildUser: function (guildid, userid, c) {
                    return this.rest('GET', `/guilds/${guildid}/members/${userid}`, '', c ? e => c(JSON.parse(e)) : undefined);
                },

                getGuildUsers: function (id, c) {
                    return this.rest('GET', `/guilds/${id}/members?limit=1000`, '', c ? e => c(JSON.parse(e)) : undefined);
                }

            }

        };

        return $api;

    }

    // init's fetchPlugins() and EPAPI5's init() had a baby
    function fetchLegacyPlugins() {

        // get the plugin array
        var plugins = window.endpwn.plugins;
        var resolved = endpwn.loader.resolved;
        //var resolved = this.resolved[key] || (this.resolved[key] = []);

        // iterate over the plugins directory
        fs.readdirSync(data + '/plugins').filter(x => x.endsWith('.js')).forEach(x => {

            // get the plugin path and manifest path
            var path = `${data}/plugins/${x}`;

            // make sure the plugin is a directory before trying to load it
            if (fs.lstatSync(path).isFile()) {

                print(`loading legacy plugin ${x}...`);

                try {

                    // krequire, the ancient function that was "partially compatible with require()" and is responsible for this file being such a clusterfuck
                    function krequire(p) {
                        return evaluate(fs.readFileSync(endpwn.data + '/plugins/' + p + (p.endsWith('.js') ? '' : '.js'), 'utf8').toString(),
                            {
                                electron: electron.remote,  // EPAPI5 adds electron.remote to the global namespace...
                                app: electron.remote.app,   // ...and electron.remote.app...
                                fs: fs,                     // ...and fs...
                                krequire: krequire,         // ...and krequire...
                                $api: epapi5()              // ...and itself
                            }
                        );
                    }

                    // this should be the only time this is ever used in an EPAPI6 plugin. ever.
                    var plugin = krequire(x);

                    // generate an id for the plugin based on its filename
                    plugin.id = `legacy.${x}`;

                    // assume the plugin depends on everything just in case
                    plugin.depends = [
                        'xyz.dr1ft.epapi.core',
                        'xyz.dr1ft.epapi.crispr',
                        'xyz.dr1ft.epapi.events',
                        'xyz.dr1ft.epapi.internal',
                        'xyz.dr1ft.epapi.rapiddom',
                        'xyz.dr1ft.epapi.ui'
                    ];

                    // someone didnt upgrade to the manifest, huh? dont worry buddy, literally no one else did either
                    if (plugin.replacements !== undefined) {

                        debug('resolving legacy replacements...');
                        var newReplacements = [];

                        // this magic line converts old CRISPR replacements to the new format which has been used internally since CRISPR 1.2 i think? maybe 1.1
                        Object.keys(plugin.replacements).map(key => { return { signature: key, payload: plugin.replacements[key] } }).forEach(x => newReplacements.push(x));

                        plugin.replacements = newReplacements;

                        // tell the runtime we've already resolved replacements for this plugin
                        addResolution('replacements', plugin.id);

                    }

                    plugin.name = 'Legacy Plugin';

                    // try to load the (widely unsupported and unused) manifest
                    if (plugin.manifest !== undefined) {

                        debug('resolving manifest...');

                        // TODO: explicitly copy values from a whitelist to disallow use of new manifest keys in legacy plugins
                        //       single file plugins need to stay in the past...
                        plugin.manifest && Object.assign(plugin, plugin.manifest);

                        if (plugin.manifest.replacements !== undefined) {
                            plugin.replacements = plugin.manifest.replacements;
                            addResolution('replacements', plugin.id);
                        }

                        plugin.name = plugin.manifest.name || 'Legacy Plugin';

                    }

                    // EPAPI6 uses a main instead of start
                    if (plugin.start) {

                        // copy start to main
                        plugin.main = plugin.start;

                        // delete the start member to clean things up
                        delete plugin.start;

                        // tell the runtime that we've already resolved main, so dont worry about it
                        addResolution('main', plugin.id);

                    }

                    // add this plugin to the global plugin cache
                    plugins.push(plugin);

                }
                catch (ex) {
                    error(ex, 'failed to load legacy plugin');
                }

            }
            else debug(`${path} is not a file, ignoring...`);

        });

    }

    module.exports = fetchLegacyPlugins;

})();
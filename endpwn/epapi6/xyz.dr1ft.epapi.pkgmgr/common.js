/*

    EndPwn Package Manager

    Copyright 2018 EndPwn Project
    
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    DO NOT EDIT THIS FILE! Your bootstrap may overwrite changes to it, and you will lose your work!
    EndPwn3 users: You can prevent this by creating a file in the same directory named DONTUPDATE
    
    https://github.com/endpwn/

*/

// TODO: comment this more

const fs = require('fs');
const request = require('request');
const rimraf = require('rimraf');
const extract = require('./extract');

module.exports = {

    get appSettings() { return DiscordNative.globals.appSettings; },

    debug: function (str) {
        console.debug(`%c[PkgMgr]%c ` + str, 'font-weight:bold;color:#0cc', '');
    },
    print: function (str) {
        console.log(`%c[PkgMgr]%c ` + str, 'font-weight:bold;color:#0cc', '');
    },
    warn: function (str) {
        console.warn(`%c[PkgMgr]%c ` + str, 'font-weight:bold;color:#0cc', '');
    },
    error: function (e, t) {
        if (t === undefined) t = 'uncaught exception';
        console.error(`%c[PkgMgr]%c ${t}:\n\n`, 'font-weight:bold;color:#0cc', '', e);
    },

    validPackageName: function (name) {
        return /^(?:[a-z0-9]+\.)+[a-z0-9]+$/.test(name);
    },

    get repos() {
        return this.appSettings.settings.REPOS || (this.appSettings.set('REPOS', []), []);
    },
    addRepo: async function (url) {
        await this.updateRepo(url);
        this.appSettings.set('REPOS', this.appSettings.settings.REPOS.concat([url]));
        this.appSettings.save();
    },
    updateRepo: async function (url) {
        this.debug(`retrieving packages from ${url}`);
        var r = await fetch(`${url}${url.endsWith('/') ? '' : '/'}packages.json?_=${Date.now()}`);
        return await r.json();
    },
    updatePackages: async function () {
        this.repos.forEach(async repo => {
            try {
                var pkgs = await this.updateRepo(repo);
                pkgs.forEach(pkg => {
                    pkg.repo = repo;
                    this.packages.push(pkg);
                });
            }
            catch (ex) {
                this.warn('failed to update packages from repo ' + repo);
            }
        })
    },

    displayDone: function () {
        this.print('done! you should probably Ctrl+R (or location.reload) in order for your changes to take effect.');
    },

    packages: [],
    installedPackages: [],

    downloadFile: function (url, path) {
        this.debug(`downloading file ${url}...`);
        return new Promise((resolve, reject) => {
            try {
                request({
                    followAllRedirects: true,
                    url: url,
                    encoding: null
                }, (err, response, body) => {
                    fs.writeFile(path, body, () => {
                        this.debug(`finished downloading ${url} to ${path}`);
                        resolve();
                    })
                });
            }
            catch (ex) {
                this.error(`failed to download ${url}`);
                reject(ex);
            }
        }
        );
    },
    downloadPackage: async function (pkg) {
        var pkgcache = `${endpwn.data}/pkgcache`;
        if (!fs.existsSync(pkgcache)) {
            fs.mkdirSync(pkgcache);
        }

        var dlpath = `${pkgcache}/${pkg.id}.zip`;
        await this.downloadFile(`${pkg.repo}${pkg.repo.endsWith('/') ? '' : '/'}${pkg.id}.zip`, `${pkgcache}/${pkg.id}.zip`);

        return dlpath;
    },
    packageInstalled: function (id) {
        if (!this.validPackageName(id)) throw 'invalid package id';
        return this.installedPackages.map(x => x.id).includes(id);
    },
    installPackage: async function (id, n = false) {
        if (!this.validPackageName(id)) throw 'invalid package id';
        this.print(`installing package ${id}`);

        var pluginPath = `${endpwn.data}/plugins/${id}`;
        this.debug(`plugin path ${pluginPath}`);
        if (this.packageInstalled(id)) {
            this.debug('package already seems to be installed, doing nothing...');
            return false;
        }

        this.debug(`resolving package ${id}`);
        var candidates = this.packages.filter(x => x.id == id);
        if (candidates.length != 1) throw 'invalid or ambiguous package';
        var pkg = candidates[0];

        if (pkg.depends)
            pkg.depends.forEach(x => {
                if (!this.packageInstalled(x)) {
                    this.debug(`installing dependency ${x}`);
                    this.installPackage(x, true);
                }
            });

        var pkgPath = await this.downloadPackage(pkg);
        this.debug(`extracting from ${pkgPath} to ${pluginPath}`);
        await extract(pkgPath, pluginPath);

        if (!n) this.displayDone();
        return true;
    },
    removePackage: async function (id, n = false) {
        if (!this.validPackageName(id)) throw 'invalid package id';
        if ([
            'xyz.dr1ft.epapi.init',
            'xyz.dr1ft.epapi.pkgmgr'
        ].includes(id)) throw 'cannot remove critical package';
        this.print(`removing package ${id}`);

        var pluginPath = `${endpwn.data}/plugins/${id}`;
        this.debug(`plugin path ${pluginPath}`);
        if (!this.packageInstalled(id)) {
            this.debug('package seems to not be installed, doing nothing...');
            return false;
        }

        await new Promise((resolve, reject) => rimraf(pluginPath, resolve));    // things that are scary: this

        if (!n) this.displayDone();
        return true;
    }

}